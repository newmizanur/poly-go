//go:build linux || darwin
// +build linux darwin

ржкрзНржпрж╛ржХрзЗржЬ main

ржЖржоржжрж╛ржирж┐ (
	"fmt"
	"time"
)

// ====== Global const/var ======
ржзрзНрж░рзБржмржХ ржЕрзНржпрж╛ржк_ржирж╛ржо рж▓рзЗржЦрж╛ = "Poly-Go Full Coverage"
ржЪрж▓ржХ ржЧрзНрж▓рзЛржмрж╛рж▓_ржЧржгржирж╛ ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛ = 0

// ====== type/struct/interface ======
ржзрж░ржг ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА ржХрж╛ржарж╛ржорзЛ {
	ржирж╛ржо  рж▓рзЗржЦрж╛
	ржмрзЯрж╕ ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛
}

ржзрж░ржг ржЧрзНрж░рж┐ржЯрж╛рж░ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ {
	ржЧрзНрж░рж┐ржЯ() рж▓рзЗржЦрж╛
}

ржлрж╛ржВрж╢ржи (u ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА) ржЧрзНрж░рж┐ржЯ() рж▓рзЗржЦрж╛ {
	ржлрзЗрж░ржд "Hello, " + u.ржирж╛ржо
}

// ====== main ======
ржлрж╛ржВрж╢ржи main() {
	fmt.Println("ЁЯЪА", ржЕрзНржпрж╛ржк_ржирж╛ржо)

	// Strings/comments must not be translated:
	// ржпржжрж┐, ржЬржирзНржп, ржлрзЗрж░ржд, ржзрж░ржг, ржХрж╛ржарж╛ржорзЛ, ржЗржирзНржЯрж╛рж░ржлрзЗрж╕, ржкрж░рж┐рж╕рж░, рж╕рзНржержЧрж┐ржд, ржирж┐рж░рзНржмрж╛ржЪржи, ржзрж╛рж░рж╛ржмрж╛рж╣рж┐ржХ, ржпрж╛ржУ
	fmt.Println("string should remain untouched: ржпржжрж┐, ржЬржирзНржп, ржлрзЗрж░ржд, ржзрж░ржг, ржХрж╛ржарж╛ржорзЛ, ржЗржирзНржЯрж╛рж░ржлрзЗрж╕")

	// ====== Escape prefix '@' ======
	@ржзрж░ржг := "this is an identifier named 'ржзрж░ржг'"
	@ржХрж╛ржарж╛ржорзЛ := 123
	@ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ := рж╕рждрзНржп
	fmt.Println("escaped:", ржзрж░ржг, ржХрж╛ржарж╛ржорзЛ, ржЗржирзНржЯрж╛рж░ржлрзЗрж╕)

	// ====== make/new/len/cap/append/copy/delete/close ======
	рж╕ржВржЦрзНржпрж╛ := ржмрж╛ржирж╛ржУ([]ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛, 0, 8)
	fmt.Println("len/cap:", ржжрзИрж░рзНржШрзНржп(рж╕ржВржЦрзНржпрж╛), ржзрж╛рж░ржгржХрзНрж╖ржорждрж╛(рж╕ржВржЦрзНржпрж╛))

	рж╕ржВржЦрзНржпрж╛ = рж╕ржВржпрзБржХрзНржд(рж╕ржВржЦрзНржпрж╛, 1, 2, 3)

	ржЧржирзНрждржмрзНржп := ржмрж╛ржирж╛ржУ([]ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛, 3)
	ржХржкрж┐_ржХрж░рж╛ := ржЕржирзБрж▓рж┐ржкрж┐(ржЧржирзНрждржмрзНржп, рж╕ржВржЦрзНржпрж╛) // copy(dst, src)
	fmt.Println("copied:", ржХржкрж┐_ржХрж░рж╛, ржЧржирзНрждржмрзНржп)

	// map keyword + delete builtin
	ржорзНржпрж╛ржк := ржмрж╛ржирж╛ржУ(ржЕржнрж┐ржзрж╛ржи[рж▓рзЗржЦрж╛]ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛)
	ржорзНржпрж╛ржк["a"] = 1
	ржорзНржпрж╛ржк["b"] = 2
	ржорзБржЫрзЛ(ржорзНржпрж╛ржк, "b")
	fmt.Println("map:", ржорзНржпрж╛ржк)

	// new builtin
	u := ржирждрзБржи(ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА)
	u.ржирж╛ржо = "Rahim"
	u.ржмрзЯрж╕ = 30

	// interface usage
	ржЪрж▓ржХ g ржЧрзНрж░рж┐ржЯрж╛рж░ = *u
	fmt.Println("greet:", g.ржЧрзНрж░рж┐ржЯ())

	// ====== for + range ======
	ржорзЛржЯ := 0
	ржЬржирзНржп _, v := ржкрж░рж┐рж╕рж░ рж╕ржВржЦрзНржпрж╛ {
		ржорзЛржЯ += v
	}
	fmt.Println("sum:", ржорзЛржЯ)

	// ====== if/else + bool/nil/error ======
	ржЪрж▓ржХ err рждрзНрж░рзБржЯрж┐ = рж╢рзВржирзНржп
	ржпржжрж┐ err == рж╢рзВржирзНржп && рж╕рждрзНржп && !ржорж┐ржерзНржпрж╛ {
		fmt.Println("nil/bool ok")
	} ржирж╛_рж╣рж▓рзЗ {
		fmt.Println("unexpected")
	}

	// ====== switch/case/default + fallthrough ======
	x := 1
	ржмрж╛ржЫрж╛ржЗ x {
	ржмрж┐ржХрж▓рзНржк 1:
		fmt.Println("case 1")
		ржзрж╛рж░рж╛ржмрж╛рж╣рж┐ржХ
	ржмрж┐ржХрж▓рзНржк 2:
		fmt.Println("case 2 (via fallthrough)")
	ржбрж┐ржлрж▓рзНржЯ:
		fmt.Println("default")
	}

	// ====== goroutine + chan + select + defer ======
	ch := ржмрж╛ржирж╛ржУ(ржЪрзНржпрж╛ржирзЗрж▓ рж▓рзЗржЦрж╛, 1)
	ржЪрж╛рж▓рж╛ржУ ржХрж╛ржЬ(ch)

	рж╕рзНржержЧрж┐ржд fmt.Println("defer executed at end of main")

	ржирж┐рж░рзНржмрж╛ржЪржи {
	ржмрж┐ржХрж▓рзНржк msg := <-ch:
		fmt.Println("select recv:", msg)
	ржбрж┐ржлрж▓рзНржЯ:
		fmt.Println("select default (no message yet)")
	}

	// ====== break/continue ======
	ржЬржирзНржп i := 0; i < 5; i++ {
		ржпржжрж┐ i == 2 {
			ржкрж░рзЗрж░ржЯрж╛рзЯ_ржпрж╛ржУ
		}
		ржпржжрж┐ i == 4 {
			ржерж╛ржорзЛ
		}
		fmt.Println("loop i:", i)
	}

	// ====== goto (keyword) demo ======
	ржпржжрж┐ ржорзЛржЯ > 0 {
		ржпрж╛ржУ ржШржЯржирж╛_рж╢рзЗрж╖
	}
	fmt.Println("this line should be skipped by goto")

ржШржЯржирж╛_рж╢рзЗрж╖:
	fmt.Println("reached label: ржШржЯржирж╛_рж╢рзЗрж╖")

	// ====== panic/recover (predeclared) demo ======
	fmt.Println("panic/recover demo:")
	fmt.Println("safeCall result:", ржирж┐рж░рж╛ржкржж_ржХрж▓())

	// ====== complex/real/imag demo (predeclared) ======
	z := ржЬржЯрж┐рж▓(2, 3) // complex(2,3)
	fmt.Println("complex:", z, "real:", ржмрж╛рж╕рзНрждржм(z), "imag:", ржХрж╛рж▓рзНржкржирж┐ржХ(z))

	fmt.Println("тП░ time:", time.Now())
	ржлрзЗрж░ржд
}

ржлрж╛ржВрж╢ржи ржХрж╛ржЬ(out ржЪрзНржпрж╛ржирзЗрж▓ рж▓рзЗржЦрж╛) {
	time.Sleep(50 * time.Millisecond)
	out <- "ржХрж╛ржЬ рж╢рзЗрж╖"
	ржШржирж┐рж╖рзНржа(out)
}

// ====== panic/recover helpers ======
ржлрж╛ржВрж╢ржи ржирж┐рж░рж╛ржкржж_ржХрж▓() рж▓рзЗржЦрж╛ {
	рж╕рзНржержЧрж┐ржд ржлрж╛ржВрж╢ржи() {
		_ = ржлрж┐рж░рзЗ_ржЖрж╕рзЛ() // recover()
	}()
	ржЖрждржЩрзНржХ("boom") // panic("boom")
	ржлрзЗрж░ржд "unreachable"
}
